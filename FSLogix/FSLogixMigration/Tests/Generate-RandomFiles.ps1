<#
.Synopsis
  Generate files with random binary data.

.DESCRIPTION
  Random files are useful for testing synchronization processes, backup/restore
  and anything in general that handles large quantities of file data.

  This script specifically does not create sparse files, or files with zeros or
  other constant data. Such data is easily compressible or can be optimize during transfer.
  Instead, the script generates pseudo-random data that cannot be optimized. The .NET 
  random generator used here is quite fast with about 100 MB/s. Writing the data
  is usually the bottleneck. 

  Some notes on usage: by default, about 15 files, 100 MB total is generated in the 
  current directory. If you specify a TargetPath, it must exist. File sizes are random betwee
  Minfilesize and Maxfilesize; these are allowed to be equal, generating fixed-size files. 
  Also, the file timestamps are randomized between <now> and 24h ago, to give
  synchronization algorithms something to work with. Filenames are generated by
  randomly shuffling the "filenameseed" string, and always end with ".bin". 

.EXAMPLE
  .\Generate-RandomFiles -Targetpath c:\temp\Randomdata

.EXAMPLE
  .\Generate-RandomFiles -Targetpath c:\temp\Randomdata -minfilesize 100MB -maxfilesize 100MB -totalsize 10GB -timerangehours 0

.NOTES
    Author: Jakub Podoba
    Last Edit: 06/29/2019
    
#>
Function Generate-RandomFiles {
  
    [CmdletBinding(SupportsShouldProcess = $True)]
    Param (
        [String] $TargetPath = $((Get-Location).Path),
        [int64] $minfilesize = 1MB,
        [int64] $maxfilesize = 1GB,
        [int64] $totalsize = 10GB,
        [int] $timerangehours = 24,
        [string] $filenameseed = "abcdefghijkl012345"   
    )
        
    Begin {
        if (-not (Split-Path -IsAbsolute $TargetPath)) {
            $TargetPath = Join-Path (Get-Location).Path $TargetPath
        }
        if (-not (Test-Path -Path $TargetPath -PathType Container )) {
            throw "TargetPath '$TargetPath' does not exist or is not a directory"
        }
        
        $currentsize = [int64]0
        $currentime = Get-Date
    }
        
    Process {
        while ($currentsize -lt $totalsize) {
            if ($minfilesize -lt $maxfilesize) {
                $filesize = Get-Random -Minimum $minfilesize -Maximum $maxfilesize
            }
            else {
                $filesize = $maxfilesize
            }
            if ($currentsize + $filesize -gt $totalsize) {
                $filesize = $totalsize - $currentsize
            }
            $currentsize += $filesize
        
            $data = new-object byte[] $filesize
            (new-object Random).NextBytes($data)
            
            $filename = ($filenameseed.ToCharArray() | Get-Random -Count ($filenameseed.Length)) -join ''
            $path = Join-Path $TargetPath "$($filename).bin"
        
            try {
                [IO.File]::WriteAllBytes($path, $data)
                if ($timerangehours -gt 0) {
                    $timestamp = $currentime.AddHours(-1 * (Get-Random -Minimum 0 -Maximum $timerangehours))
                }
                else {
                    $timestamp = $currentime
                }
                $fileobject = Get-Item -Path $path
                $fileobject.CreationTime = $timestamp
                $fileobject.LastWriteTime = $timestamp
        
                [pscustomobject] @{
                    filename  = $path
                    timestamp = $timestamp
                    datasize  = $filesize
                }
            }
            catch {
                $message = "failed to write data to $path, error $($_.Exception.Message)"
                Throw $message
            }    
        }
    }
    
    End {
    }
}